<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2022-09-29T22:53:22-07:00</updated><id>/feed.xml</id><title type="html">Notes, Thoughts, and Adventures</title><subtitle>...</subtitle><entry><title type="html">Docker for Windows</title><link href="/wsl/2022/09/29/docker_wsl.html" rel="alternate" type="text/html" title="Docker for Windows" /><published>2022-09-29T00:00:00-07:00</published><updated>2022-09-29T00:00:00-07:00</updated><id>/wsl/2022/09/29/docker_wsl</id><content type="html" xml:base="/wsl/2022/09/29/docker_wsl.html"><![CDATA[<p>There are two options to support running Linux containers on Windows; Docker
Desktop and Docker under WSL2. Docker Desktop
<a href="https://www.docker.com/pricing/faq/">may require a subscription for business use</a>.
However, it is easy to set up and run. In addition, it provides a simple way
to work on Windows Containers. Here is an overview of the two:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Category</th>
      <th style="text-align: right">Docker Desktop</th>
      <th style="text-align: right">WSL2 Docker</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Resources</td>
      <td style="text-align: right">Light</td>
      <td style="text-align: right">Very Light</td>
    </tr>
    <tr>
      <td style="text-align: left">Availability</td>
      <td style="text-align: right">Global</td>
      <td style="text-align: right">Distro</td>
    </tr>
    <tr>
      <td style="text-align: left">Ease of Use</td>
      <td style="text-align: right">Easy</td>
      <td style="text-align: right">Moderate</td>
    </tr>
    <tr>
      <td style="text-align: left">License</td>
      <td style="text-align: right"><a href="https://www.docker.com/pricing/faq/">Business - $</a></td>
      <td style="text-align: right">Free</td>
    </tr>
    <tr>
      <td style="text-align: left">Windows Containers</td>
      <td style="text-align: right">Yes</td>
      <td style="text-align: right">No</td>
    </tr>
  </tbody>
</table>

<h3 id="resources">Resources</h3>

<p>Both the Docker Desktop and the WSL2 Docker are light on resources. Take,
for example, my oldest machine, the 1st generation Surface Pro. With a humble
4GB of RAM, I can build and run containers, have an instance of WSL2 running for
development, VS Code, and still squeeze in several browser tabs. That said,
WSL2 Docker gets a slight lead here, as there is no desktop client or additional
WSL2 distros that need to run.</p>

<p>The startup time for Docker Desktop is a lot longer than WSL2 Docker. It took
over a minute for Docker Desktop to start. Half of that time was bringing up the
application, and the other half was waiting for the docker icon in the system
tray to indicate it was ready. Compare that to WSL2 Docker, which started in
less than 5 seconds. That time also includes bringing up the WSL2 distro as
well.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Engine</th>
      <th style="text-align: right">Startup Time</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Docker Desktop</td>
      <td style="text-align: right">68s</td>
    </tr>
    <tr>
      <td style="text-align: left">WSL2 Docker</td>
      <td style="text-align: right">3.54s</td>
    </tr>
  </tbody>
</table>

<p>Once things are up and running, performance becomes similar between the two.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: right">Docker Desktop</th>
      <th style="text-align: right">WSL2 Docker</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">split 50k files</td>
      <td style="text-align: right">6.87s</td>
      <td style="text-align: right">4.07s</td>
    </tr>
    <tr>
      <td style="text-align: left">rm 50k files</td>
      <td style="text-align: right">2.66s</td>
      <td style="text-align: right">2.05s</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Benchmarks performed on a 1st generation Surface Pro with 64GB SSD. Your
results will see improvement with better hardware.</p>
</blockquote>

<h3 id="availability">Availability</h3>

<p>When Docker Desktop is installed, the client is available in the Windows
Console, under both the Command Prompt and PowerShell. It can also be added to
any WSL2 distro with a few clicks in the desktop app. There is no need to
install the client for that distro; Docker will stub out everything in it with a
single click.</p>

<p><img src="/assets/docker_desktop_wsl_integration.png" alt="Docker Desktop WSL Integration" title="Docker Desktop WSL Integration" /></p>

<p>The WSL2 Docker will, by default, use <code class="language-plaintext highlighter-rouge">/var/run/docker.sock</code> in the distro. Only the
client on the same distro can use the Docker daemon.</p>

<h3 id="ease-of-use">Ease of Use</h3>

<p>Docker provides a desktop application to configure the Docker daemon and enable WSL
integration with other distros. In addition, it also gives a friendly visual interface
for managing images, containers, and volumes.</p>

<p>This is in contrast to WSL2 Docker, where you manage it as you would in Linux, via
the JSON configuration file <code class="language-plaintext highlighter-rouge">/etc/docker/daemon.json</code> and using the client
command-line interface (CLI) to handle container images, running containers, and
so forth.</p>

<h3 id="license">License</h3>

<p>Docker Desktop is free for businesses with less than 250 employees and $10
million in annual revenue at the time of this writing. Otherwise, it is a
minimum of $5 per month per user. Docker in WSL2 uses the open-source components
of Docker, such as containerd, and is free to use.</p>

<h3 id="windows-containers">Windows Containers</h3>

<p>For Docker Desktop, right-click the application in the system tray and
select <code class="language-plaintext highlighter-rouge">Switch to Windows Containers</code>. WSL2 Docker will only run Linux containers.</p>

<h2 id="docker-desktop">Docker Desktop</h2>

<p>Installing Docker Desktop is a piece of cake. They even provide a tutorial
once the application is running to guide you through running a container. See
https://docs.docker.com/desktop/windows/install/</p>

<p>Historically, Docker Desktop used to run a dedicated VM. Now, by default, it
runs on top of WSL2. Technically, it is still a VM but is highly optimized for
resource conservation. I evaluated it using a 1st gen Surface Pro with just 4GB
of RAM while having VS Code, a dozen tabs, and Spotify playing in the
background. The older dedicated VM implementation would require at decent chunk
of free memory to start it successfully, so the only way to launch Docker on 4GB
of RAM was after a reboot.</p>

<p>Docker Desktop installs two distros in WSL. One is <code class="language-plaintext highlighter-rouge">docker-desktop</code>, a
lightweight distro based on BusyBox that runs the Docker daemon and a host of
other processes. And <code class="language-plaintext highlighter-rouge">docker-desktop-data</code>, which contains what appears to be
cached build layers from built containers.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>wsl.exe <span class="nt">-l</span> <span class="nt">-v</span>
  NAME                   STATE           VERSION
<span class="k">*</span> Ubuntu                 Running         2
  docker-desktop-data    Running         2
  docker-desktop         Running         2
</code></pre></div></div>

<h3 id="cross-distro-support">Cross Distro Support</h3>

<p>When a WSL2 distro is integrated with Docker Desktop, it will run a process
called <code class="language-plaintext highlighter-rouge">docker-desktop-proxy</code></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ps aux | <span class="nb">grep </span>docker
root 5632  /wsl/docker-desktop/docker-desktop-proxy <span class="nt">--distro-name</span> Ubuntu <span class="nt">--docker-desktop-root</span> /wsl/docker-desktop
</code></pre></div></div>

<p>It will also set up <code class="language-plaintext highlighter-rouge">docker.sock</code> under <code class="language-plaintext highlighter-rouge">/var/run</code> and provide symbolic
links under <code class="language-plaintext highlighter-rouge">/usr/bin</code> programs like the docker client and docker-compose.</p>

<p>Lastly, it mounts directories between the Docker distros and your chosen distros,
under <code class="language-plaintext highlighter-rouge">/wsl</code>. This is, for now, an undocumented feature of WSL that Docker
Desktop utilizes. See WSL GitHub issues <a href="https://github.com/microsoft/WSL/issues/4577">#4577</a> and
<a href="https://github.com/microsoft/WSL/issues/5177">#5177</a> for further information.</p>

<p>This enables Docker Desktop to work across distros, using the same Docker daemon.</p>

<h2 id="docker-on-wsl2">Docker on WSL2</h2>

<p>Installing Docker in WSL2 is the same as it is under Linux. Update the
package tool to use Docker’s package repository and install all the needed
components that makeup Docker.</p>

<p><a href="https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository">https://docs.docker.com/engine/install/ubuntu/#install-using-the-repository</a></p>

<p>In addition, you may want to add your user account to the docker group.</p>

<p><a href="https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user">https://docs.docker.com/engine/install/linux-postinstall/#manage-docker-as-a-non-root-user</a></p>

<p>With that, you should be all set with Docker in WSL2.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">sudo </span>service docker start
<span class="nv">$ </span>docker run hello-world

Hello from Docker!
This message shows that your installation appears to be working correctly.
...
</code></pre></div></div>

<h2 id="starting-docker-automatically">Starting Docker automatically</h2>

<p>If you are on Windows 11, you may be able to support <a href="https://devblogs.microsoft.com/commandline/systemd-support-is-now-available-in-wsl/">systemd for WSL2</a>.
You can use the same configuration as Linux to have
<a href="https://docs.docker.com/engine/install/linux-postinstall/#configure-docker-to-start-on-boot">Docker Start on boot</a>.</p>

<p>If <code class="language-plaintext highlighter-rouge">systemd</code> is not supported on your system, there is a quick way to have Docker start
when you log in to Windows.</p>

<p>First, get the distro name that you installed Docker on.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>wsl.exe <span class="nt">-l</span> <span class="nt">-v</span>
  NAME      STATE           VERSION
<span class="k">*</span> Ubuntu    Running         2
</code></pre></div></div>

<p>In my case, the distro name is <code class="language-plaintext highlighter-rouge">Ubuntu</code>. Open the Windows Run Dialog (WIN + R)
and enter <code class="language-plaintext highlighter-rouge">shell:startup</code>. The file explorer will open the startup folder for
your user account. Create a batch file such as <code class="language-plaintext highlighter-rouge">wsl_boot_script.bat</code> and add the
following to the script:</p>

<div class="language-batch highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">wsl</span> <span class="na">-d </span><span class="kd">Ubuntu</span> <span class="na">-u </span><span class="kd">root</span> <span class="na">-e </span><span class="kd">sudo</span> <span class="kd">service</span> <span class="kd">docker</span> <span class="nb">start</span>
</code></pre></div></div>

<p>And that’s it! Next time you log in to your Windows account, the script will start Docker.</p>]]></content><author><name></name></author><category term="wsl" /><category term="docker" /><summary type="html"><![CDATA[There are two options to support running Linux containers on Windows; Docker Desktop and Docker under WSL2. Docker Desktop may require a subscription for business use. However, it is easy to set up and run. In addition, it provides a simple way to work on Windows Containers. Here is an overview of the two:]]></summary></entry><entry><title type="html">WSL2 Windows 10 Disk Performance</title><link href="/wsl/2022/02/20/wsl2_disk_perf.html" rel="alternate" type="text/html" title="WSL2 Windows 10 Disk Performance" /><published>2022-02-20T00:00:00-08:00</published><updated>2022-02-20T00:00:00-08:00</updated><id>/wsl/2022/02/20/wsl2_disk_perf</id><content type="html" xml:base="/wsl/2022/02/20/wsl2_disk_perf.html"><![CDATA[<p>I do a lot of projects both for Windows applications and backend web development
that runs on Linux. While my Windows projects do not run under Linux, I enjoy
using the command line via WSL while working on them.</p>

<p>I set up another distro using WSL2 for my backend projects, and then pondered,
should I continue to use my WSL1 configured distro? Let’s find out!</p>

<h1 id="measuring-performance">Measuring performance</h1>

<p>Here is what I used to measure disk performance. Feel free to try it out on
your system. Depending on your machine and which scenario you are attempting
it can range from a few seconds to a few minutes.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir test
cd test
dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>testfile <span class="nv">bs</span><span class="o">=</span>1000 <span class="nv">count</span><span class="o">=</span>500
<span class="nb">time split</span> <span class="nt">-b</span> 10 <span class="nt">-a</span> 10 testfile
<span class="nb">time rm</span> <span class="nt">-rf</span> <span class="k">*</span>
</code></pre></div></div>

<p>The above command generates 50k files by generating a 500KB file, splitting it
into files of 10 bytes, and lastly removing all the files.</p>

<h1 id="results">Results</h1>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: right">WSL2 on VHD</th>
      <th style="text-align: right">WSL2 on NTFS</th>
      <th style="text-align: right">WSL1 on NTFS*</th>
      <th style="text-align: right">Docker (WSL2)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">split 50k files</td>
      <td style="text-align: right">4.22s</td>
      <td style="text-align: right">3m58.8s</td>
      <td style="text-align: right">39.95s</td>
      <td style="text-align: right">5.89s</td>
    </tr>
    <tr>
      <td style="text-align: left">rm 50k files</td>
      <td style="text-align: right">1.85s</td>
      <td style="text-align: right">1m58.2s</td>
      <td style="text-align: right">18.71s</td>
      <td style="text-align: right">2.42s</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>* WSL1 with optimizations, see <a href="/wsl/2019/11/03/wsl_disk_perf.html">WSL Disk performance</a></p>
</blockquote>

<blockquote>
  <p>Benchmarks performed on a 1st generation Surface Pro with 64GB SSD. Your
results will see a pronounced improvement with better hardware.</p>
</blockquote>

<p>A couple of things pop out from the results. First is the stark difference between
WSL2 using the VM drive versus using NTFS mounted drive. You can see WSL2 on NTFS gives
the worst performance at nearly 4 minutes, fifty times slower than the same test
on the VM drive.</p>

<p>Second, WSL1 is faster on NTFS. Even factoring out the optimizations from
<a href="/wsl/2019/11/03/wsl_disk_perf.html">WSL Disk performance</a> there is still a
2-3x performance gain by sticking with WSL1 for operations on the NTFS drive.
That explains why <a href="https://docs.microsoft.com/en-us/windows/wsl/compare-versions#exceptions-for-using-wsl-1-rather-than-wsl-2">Microsoft suggests using WSL1</a> if you need to work with
files in the Windows File System.</p>]]></content><author><name></name></author><category term="wsl" /><summary type="html"><![CDATA[I do a lot of projects both for Windows applications and backend web development that runs on Linux. While my Windows projects do not run under Linux, I enjoy using the command line via WSL while working on them.]]></summary></entry><entry><title type="html">Git for Windows using WSL</title><link href="/wsl/2019/12/12/wsl_cross_plat_git.html" rel="alternate" type="text/html" title="Git for Windows using WSL" /><published>2019-12-12T00:00:00-08:00</published><updated>2019-12-12T00:00:00-08:00</updated><id>/wsl/2019/12/12/wsl_cross_plat_git</id><content type="html" xml:base="/wsl/2019/12/12/wsl_cross_plat_git.html"><![CDATA[<p>For several years I used <a href="https://git-scm.com/download/win">Git for Windows</a> to manage
repositories and it was decent enough. However, I found the Unix-like environment provided by Git
for Windows to be very different than what I was used to. I have longed for a way to use Git from
WSL to manage my repositories and continue to support tooling dependent on Git that ran on
Windows</p>

<h1 id="whats-the-catch">What’s the catch?</h1>

<p>This assumes that you use SSH keys for authentication. If you use passphrases on your keys then
an ssh-agent should be setup. If you use HTTPS authentication then it will require a workaround
to function in WSL.</p>

<h2 id="performance">Performance</h2>

<p>In my day to day activities running Git from WSL, I have not found performance to be different
between the two. Below is a quick comparison of cloning a repository.</p>

<p><code class="language-plaintext highlighter-rouge">git clone</code> using Git for Windows
<img src="/assets/git_clone_git_on_win.png" alt="git clone - Git for Windows" title="git clone using Git for Windows" /></p>

<p><code class="language-plaintext highlighter-rouge">git clone</code> using WSL
<img src="/assets/git_clone_wsl.png" alt="git clone - WSL" title="git clone using WSL" /></p>

<blockquote>
  <p>Note: WSL had improvements from <a href="/wsl/2019/11/03/wsl_disk_perf.html">WSL Disk performance</a></p>
</blockquote>

<h1 id="moving-the-git-configuration-to-wsl">Moving the Git configuration to WSL</h1>

<p>Git for Windows by default uses your user profile (<code class="language-plaintext highlighter-rouge">%USERPROFILE%</code>) directory to store
configuration and SSH keys. Since the systems are mostly the same, you can copy them over to WSL.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd /mnt/c/Users/&lt;your_username&gt;
mv .gitconfig ~
mv .ssh/ ~
</code></pre></div></div>

<p>The private SSH key file permissions need to be updated, follow the step below for your keys.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod 600 ~/.ssh/&lt;your_key&gt;
</code></pre></div></div>

<h1 id="line-endings">Line Endings</h1>

<p>Git may convert line endings to CRLF on checkout. If you are not paying attention this can cause
some head-scratching during code reviews. Setting autocrlf to <code class="language-plaintext highlighter-rouge">input</code> will checkout with line
endings left as-is, and will convert them to LF when committing.</p>

<p>Enter the following in your WSL console.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git config --global core.autocrlf input
</code></pre></div></div>

<p>It is recommended that repositories contain <code class="language-plaintext highlighter-rouge">.gitattrbutes</code>; a configuration file that defines the
desired line endings that will override the user settings. See 
<a href="https://help.github.com/en/github/using-git/configuring-git-to-handle-line-endings">Configuring Git to Handle Line Endings</a>
for further information on configuration Git Attributes.</p>

<h1 id="use-wsl-git-from-windows">Use WSL Git from Windows</h1>

<p>Using the WSL command line, you can clone, commit, push, etc. without any issues. However, tools from
the Windows side, such as VS Code, will still be calling to Git for Windows for Git operations.
Luckily there is a tool called <a href="https://github.com/andy-5/wslgit">wslgit</a> to forward those calls
to WSL git.</p>

<ol>
  <li>Create a directory under %programfiles% called <code class="language-plaintext highlighter-rouge">wslgit</code>.</li>
  <li>Download the <a href="https://github.com/andy-5/wslgit">wslgit</a> tool and save it under the folder created
earlier.</li>
  <li>Rename <code class="language-plaintext highlighter-rouge">wslgit.exe</code> to <code class="language-plaintext highlighter-rouge">git.exe</code></li>
  <li>Update the PATH user environment variable to include the path <code class="language-plaintext highlighter-rouge">git.exe</code> under
<code class="language-plaintext highlighter-rouge">%programfiles%\wslgit</code>. If Git for Windows is also in the path make sure this precedes it.</li>
  <li>Create a new user environment variable <code class="language-plaintext highlighter-rouge">WSLGIT_USE_INTERACTIVE_SHELL</code> and set the value to <code class="language-plaintext highlighter-rouge">0</code>.</li>
</ol>

<p>At this point, you should be able to run a PowerShell or Windows CMD session and execute <code class="language-plaintext highlighter-rouge">git</code>. You
may have to restart an existing session for changes to take effect.</p>

<p>Finally, I recommend uninstalling Git for Windows. Switching between Git for Windows and using
Git in WSL in the same repository will likely break it.</p>]]></content><author><name></name></author><category term="wsl" /><category term="git" /><summary type="html"><![CDATA[For several years I used Git for Windows to manage repositories and it was decent enough. However, I found the Unix-like environment provided by Git for Windows to be very different than what I was used to. I have longed for a way to use Git from WSL to manage my repositories and continue to support tooling dependent on Git that ran on Windows What’s the catch? This assumes that you use SSH keys for authentication. If you use passphrases on your keys then an ssh-agent should be setup. If you use HTTPS authentication then it will require a workaround to function in WSL. Performance In my day to day activities running Git from WSL, I have not found performance to be different between the two. Below is a quick comparison of cloning a repository. git clone using Git for Windows git clone using WSL Note: WSL had improvements from WSL Disk performance Moving the Git configuration to WSL Git for Windows by default uses your user profile (%USERPROFILE%) directory to store configuration and SSH keys. Since the systems are mostly the same, you can copy them over to WSL. cd /mnt/c/Users/&lt;your_username&gt; mv .gitconfig ~ mv .ssh/ ~ The private SSH key file permissions need to be updated, follow the step below for your keys. chmod 600 ~/.ssh/&lt;your_key&gt; Line Endings Git may convert line endings to CRLF on checkout. If you are not paying attention this can cause some head-scratching during code reviews. Setting autocrlf to input will checkout with line endings left as-is, and will convert them to LF when committing. Enter the following in your WSL console. git config --global core.autocrlf input It is recommended that repositories contain .gitattrbutes; a configuration file that defines the desired line endings that will override the user settings. See Configuring Git to Handle Line Endings for further information on configuration Git Attributes. Use WSL Git from Windows Using the WSL command line, you can clone, commit, push, etc. without any issues. However, tools from the Windows side, such as VS Code, will still be calling to Git for Windows for Git operations. Luckily there is a tool called wslgit to forward those calls to WSL git. Create a directory under %programfiles% called wslgit. Download the wslgit tool and save it under the folder created earlier. Rename wslgit.exe to git.exe Update the PATH user environment variable to include the path git.exe under %programfiles%\wslgit. If Git for Windows is also in the path make sure this precedes it. Create a new user environment variable WSLGIT_USE_INTERACTIVE_SHELL and set the value to 0. At this point, you should be able to run a PowerShell or Windows CMD session and execute git. You may have to restart an existing session for changes to take effect. Finally, I recommend uninstalling Git for Windows. Switching between Git for Windows and using Git in WSL in the same repository will likely break it.]]></summary></entry><entry><title type="html">WSL Disk Performance</title><link href="/wsl/2019/11/03/wsl_disk_perf.html" rel="alternate" type="text/html" title="WSL Disk Performance" /><published>2019-11-03T00:00:00-07:00</published><updated>2019-11-03T00:00:00-07:00</updated><id>/wsl/2019/11/03/wsl_disk_perf</id><content type="html" xml:base="/wsl/2019/11/03/wsl_disk_perf.html"><![CDATA[<p>The Windows NTFS file system is not a strong performer with small files in comparison with ext4. This
is a large reason why operations like building a virtual environment in Python or installing a package
take noticeably longer in Windows.</p>

<p>One way around this is to use
<a href="https://docs.microsoft.com/en-us/windows/wsl/wsl2-about">WSL2</a>, which is a
different variant of WSL that runs under a specialized, lightweight VM. It
provides a far more performant experience than WSL1 and alleviates other
shortcomings of WSL1. See <a href="/wsl/2022/02/20/wsl2_disk_perf.html">WSL2 Disk Performance</a>
for a performance comparison between the two.</p>

<h1 id="measuring-performance">Measuring performance</h1>

<p>Pull up a WSL terminal and enter the following commands. Expect them to take a minute
or two to execute and take note of the times.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir test
cd test
dd </span><span class="k">if</span><span class="o">=</span>/dev/zero <span class="nv">of</span><span class="o">=</span>testfile <span class="nv">bs</span><span class="o">=</span>1000 <span class="nv">count</span><span class="o">=</span>500
<span class="nb">time split</span> <span class="nt">-b</span> 10 <span class="nt">-a</span> 10 testfile
<span class="nb">time rm</span> <span class="nt">-rf</span> <span class="k">*</span>
</code></pre></div></div>

<p>The above command generates 50k files by generating a 500KB file, splitting it into files 
of 10 bytes, and lastly removing all the files.</p>

<h1 id="disable-83-naming">Disable 8.3 Naming</h1>

<p>The <a href="https://en.wikipedia.org/wiki/8.3_filename">8.3 file naming convention</a>
was used in DOS and early versions of Windows. To maintain backward
compatibility with programs over two decades old, Windows enumerates longer file names with the 8.3
conventions. This results in additional overhead that adds up when handling a large number of files.</p>

<p>Open the Windows command shell as Administrator. Enter the following to see if 8dot3 naming is
enabled for your system drive.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">fsutil.exe</span><span class="w"> </span><span class="nx">8dot3name</span><span class="w"> </span><span class="nx">query</span><span class="w"> </span><span class="nx">C:</span><span class="w">
</span><span class="n">The</span><span class="w"> </span><span class="nx">volume</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="nx">is:</span><span class="w"> </span><span class="nx">0</span><span class="w"> </span><span class="p">(</span><span class="mi">8</span><span class="n">dot3</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">creation</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">enabled</span><span class="p">)</span><span class="o">.</span><span class="w">
</span><span class="n">The</span><span class="w"> </span><span class="nx">registry</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="nx">is:</span><span class="w"> </span><span class="nx">2</span><span class="w"> </span><span class="p">(</span><span class="n">Per</span><span class="w"> </span><span class="nx">volume</span><span class="w"> </span><span class="nx">setting</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">default</span><span class="p">)</span><span class="o">.</span><span class="w">

</span><span class="n">Based</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">the</span><span class="w"> </span><span class="nx">above</span><span class="w"> </span><span class="nx">settings</span><span class="p">,</span><span class="w"> </span><span class="nx">8dot3</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">creation</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">enabled</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">C:</span><span class="w">
</span></code></pre></div></div>

<p>The enumeration can be turned off at any time and may be turned off either per NTFS
volume or for all volumes.</p>

<p>Here is how to disable the enumeration on all NTFS volumes:</p>
<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">fsutil.exe</span><span class="w"> </span><span class="nx">behavior</span><span class="w"> </span><span class="nx">set</span><span class="w"> </span><span class="nx">disable8dot3</span><span class="w"> </span><span class="nx">1</span><span class="w">
</span><span class="n">The</span><span class="w"> </span><span class="nx">registry</span><span class="w"> </span><span class="nx">state</span><span class="w"> </span><span class="nx">is</span><span class="w"> </span><span class="nx">now:</span><span class="w"> </span><span class="nx">1</span><span class="w"> </span><span class="p">(</span><span class="n">Disable</span><span class="w"> </span><span class="nx">8dot3</span><span class="w"> </span><span class="nx">name</span><span class="w"> </span><span class="nx">creation</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">volumes</span><span class="p">)</span><span class="o">.</span><span class="w">
</span></code></pre></div></div>

<p>Disabling 8dot3 naming prevents 8.3 enumerations on files created after the change. Existing files
in the directory created beforehand will continue to slow performance. Either re-create
those files or check out 
<a href="https://blogs.technet.microsoft.com/josebda/2012/11/13/windows-server-2012-file-server-tip-disable-8-3-naming-and-strip-those-short-names-too/">Disable 8.3 Naming (and strip those short names too)</a>
on how to remove short names from the files.</p>

<h1 id="update-real-time-protection-to-exclude-linux-processes">Update real-time protection to exclude Linux processes</h1>

<p>By default, Windows Defender will scan files being used by a process. This
impacts processes that perform a lot of file operations.
Some suggest to turn off real-time protection; a better way is to
exclude files those processes are working with from being scanned
in real-time.</p>

<p>Issue the <code class="language-plaintext highlighter-rouge">which</code> command in WSL to determine where the executable location of the process lives.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>phil@small-kine:/mnt/c/dev/dd_test<span class="nv">$ </span>which <span class="nb">split</span>
/usr/bin/split
phil@small-kine:/mnt/c/dev/dd_test<span class="nv">$ </span>which <span class="nb">rm</span>
/bin/rm
</code></pre></div></div>

<p>Next, update the real-time protection to exclude that process or all processes
in that folder. Shown below is how to exclude processes located in the <code class="language-plaintext highlighter-rouge">/usr/bin</code> and
<code class="language-plaintext highlighter-rouge">/bin</code> directories.</p>

<p>The following assumes that there is only one distribution installed for WSL, Ubuntu.
It is possible to have multiple distributions (Alpine, Debian, etc.) and multiple
versions of them. For those situations, change the <code class="language-plaintext highlighter-rouge">Where-Object</code> query in
the first command below to pick the correct WSL package.</p>

<p>Open Windows PowerShell as Administrator and enter the following commands.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nv">$wsl_target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="n">IO.Path</span><span class="p">]::</span><span class="n">Combine</span><span class="p">(</span><span class="nv">$</span><span class="nn">env</span><span class="p">:</span><span class="nv">LOCALAPPDATA</span><span class="p">,</span><span class="w"> </span><span class="s2">"Packages"</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">Get-AppxPackage</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Where-Object</span><span class="w"> </span><span class="nt">-Property</span><span class="w"> </span><span class="s2">"Name"</span><span class="w"> </span><span class="o">-Like</span><span class="w"> </span><span class="s2">"*Ubuntu*"</span><span class="p">)</span><span class="o">.</span><span class="nf">PackageFamilyName</span><span class="p">,</span><span class="w"> </span><span class="s2">"LocalState"</span><span class="p">,</span><span class="w"> </span><span class="s2">"rootfs"</span><span class="p">)</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Test-Path</span><span class="w"> </span><span class="nv">$wsl_target</span><span class="w">
</span><span class="n">True</span><span class="w">
</span><span class="nx">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Add-MpPreference</span><span class="w"> </span><span class="nt">-ExclusionProcess</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$wsl_target</span><span class="w"> </span><span class="nt">-ChildPath</span><span class="w"> </span><span class="s2">"/usr/bin/*"</span><span class="p">)</span><span class="w">
</span><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Add-MpPreference</span><span class="w"> </span><span class="nt">-ExclusionProcess</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$wsl_target</span><span class="w"> </span><span class="nt">-ChildPath</span><span class="w"> </span><span class="s2">"/bin/*"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<p>Here is an example for excluding Node.js processes under NVM.</p>

<div class="language-powershell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PS</span><span class="w"> </span><span class="nx">C:\WINDOWS\system32</span><span class="err">&gt;</span><span class="w"> </span><span class="nx">Add-MpPreference</span><span class="w"> </span><span class="nt">-ExclusionProcess</span><span class="w"> </span><span class="p">(</span><span class="n">Join-Path</span><span class="w"> </span><span class="nv">$wsl_target</span><span class="w"> </span><span class="nt">-ChildPath</span><span class="w"> </span><span class="s2">"/home/your_home_dir/.nvm/versions/node/*"</span><span class="p">)</span><span class="w">
</span></code></pre></div></div>

<blockquote>
  <p>While WSL processes are run from directories under <code class="language-plaintext highlighter-rouge">%localappdata%\Packages\...</code>, they are not
meant to be used for file access, use <code class="language-plaintext highlighter-rouge">\\wsl$\</code> instead.</p>
</blockquote>

<p>Check out
<a href="https://docs.microsoft.com/en-us/windows/security/threat-protection/windows-defender-antivirus/configure-process-opened-file-exclusions-windows-defender-antivirus">Defender Anti-Virus Configure Process Exclusions</a>
for further configuration options for Windows Defender.</p>

<h1 id="performance">Performance</h1>

<p>Using the file I/O example provided earlier and running a benchmark you can see a marked improvement
in performance using the proceeding techniques. That said, there still is dramatic difference
between WSL and Linux in raw performance.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: right">WSL</th>
      <th style="text-align: right">WSL with changes</th>
      <th style="text-align: right">Docker (VM)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">split 50k files</td>
      <td style="text-align: right">2m3.72s</td>
      <td style="text-align: right">39.95s</td>
      <td style="text-align: right">4.95s</td>
    </tr>
    <tr>
      <td style="text-align: left">rm 50k files</td>
      <td style="text-align: right">27.15s</td>
      <td style="text-align: right">18.71s</td>
      <td style="text-align: right">2.04s</td>
    </tr>
  </tbody>
</table>

<p>Taking a look at some workflows and how their performance varies between systems those differences
are not as substantial as before, but still noticeable.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Operation</th>
      <th style="text-align: right">WSL</th>
      <th style="text-align: right">WSL with changes</th>
      <th style="text-align: right">Docker (VM)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Python 3.6.9 venv creation</td>
      <td style="text-align: right">12.63s</td>
      <td style="text-align: right">5.86s</td>
      <td style="text-align: right">3.17s</td>
    </tr>
    <tr>
      <td style="text-align: left">npm create next-app</td>
      <td style="text-align: right">2m33.90s</td>
      <td style="text-align: right">1m13.31s</td>
      <td style="text-align: right">24.95s</td>
    </tr>
    <tr>
      <td style="text-align: left">next.js project build</td>
      <td style="text-align: right">45.91s</td>
      <td style="text-align: right">21.01s</td>
      <td style="text-align: right">20.83s</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>Benchmarks performed on a 1st generation Surface Pro with 64GB SSD. Your results will see a
pronounced improvement with better hardware.</p>
</blockquote>

<blockquote>
  <p>Node.js 12.13 LTS used for next.js benchmarks.</p>
</blockquote>]]></content><author><name></name></author><category term="wsl" /><category term="performance" /><summary type="html"><![CDATA[The Windows NTFS file system is not a strong performer with small files in comparison with ext4. This is a large reason why operations like building a virtual environment in Python or installing a package take noticeably longer in Windows. One way around this is to use WSL2, which is a different variant of WSL that runs under a specialized, lightweight VM. It provides a far more performant experience than WSL1 and alleviates other shortcomings of WSL1. See WSL2 Disk Performance for a performance comparison between the two. Measuring performance Pull up a WSL terminal and enter the following commands. Expect them to take a minute or two to execute and take note of the times. mkdir test cd test dd if=/dev/zero of=testfile bs=1000 count=500 time split -b 10 -a 10 testfile time rm -rf * The above command generates 50k files by generating a 500KB file, splitting it into files of 10 bytes, and lastly removing all the files. Disable 8.3 Naming The 8.3 file naming convention was used in DOS and early versions of Windows. To maintain backward compatibility with programs over two decades old, Windows enumerates longer file names with the 8.3 conventions. This results in additional overhead that adds up when handling a large number of files. Open the Windows command shell as Administrator. Enter the following to see if 8dot3 naming is enabled for your system drive. PS C:\WINDOWS\system32&gt; fsutil.exe 8dot3name query C: The volume state is: 0 (8dot3 name creation is enabled). The registry state is: 2 (Per volume setting - the default). Based on the above settings, 8dot3 name creation is enabled on C: The enumeration can be turned off at any time and may be turned off either per NTFS volume or for all volumes. Here is how to disable the enumeration on all NTFS volumes: PS C:\WINDOWS\system32&gt; fsutil.exe behavior set disable8dot3 1 The registry state is now: 1 (Disable 8dot3 name creation on all volumes). Disabling 8dot3 naming prevents 8.3 enumerations on files created after the change. Existing files in the directory created beforehand will continue to slow performance. Either re-create those files or check out Disable 8.3 Naming (and strip those short names too) on how to remove short names from the files. Update real-time protection to exclude Linux processes By default, Windows Defender will scan files being used by a process. This impacts processes that perform a lot of file operations. Some suggest to turn off real-time protection; a better way is to exclude files those processes are working with from being scanned in real-time. Issue the which command in WSL to determine where the executable location of the process lives. phil@small-kine:/mnt/c/dev/dd_test$ which split /usr/bin/split phil@small-kine:/mnt/c/dev/dd_test$ which rm /bin/rm Next, update the real-time protection to exclude that process or all processes in that folder. Shown below is how to exclude processes located in the /usr/bin and /bin directories. The following assumes that there is only one distribution installed for WSL, Ubuntu. It is possible to have multiple distributions (Alpine, Debian, etc.) and multiple versions of them. For those situations, change the Where-Object query in the first command below to pick the correct WSL package. Open Windows PowerShell as Administrator and enter the following commands. PS C:\WINDOWS\system32&gt; $wsl_target = [IO.Path]::Combine($env:LOCALAPPDATA, "Packages", (Get-AppxPackage | Where-Object -Property "Name" -Like "*Ubuntu*").PackageFamilyName, "LocalState", "rootfs") PS C:\WINDOWS\system32&gt; Test-Path $wsl_target True PS C:\WINDOWS\system32&gt; Add-MpPreference -ExclusionProcess (Join-Path $wsl_target -ChildPath "/usr/bin/*") PS C:\WINDOWS\system32&gt; Add-MpPreference -ExclusionProcess (Join-Path $wsl_target -ChildPath "/bin/*") Here is an example for excluding Node.js processes under NVM. PS C:\WINDOWS\system32&gt; Add-MpPreference -ExclusionProcess (Join-Path $wsl_target -ChildPath "/home/your_home_dir/.nvm/versions/node/*") While WSL processes are run from directories under %localappdata%\Packages\..., they are not meant to be used for file access, use \\wsl$\ instead. Check out Defender Anti-Virus Configure Process Exclusions for further configuration options for Windows Defender. Performance Using the file I/O example provided earlier and running a benchmark you can see a marked improvement in performance using the proceeding techniques. That said, there still is dramatic difference between WSL and Linux in raw performance. Operation WSL WSL with changes Docker (VM) split 50k files 2m3.72s 39.95s 4.95s rm 50k files 27.15s 18.71s 2.04s Taking a look at some workflows and how their performance varies between systems those differences are not as substantial as before, but still noticeable. Operation WSL WSL with changes Docker (VM) Python 3.6.9 venv creation 12.63s 5.86s 3.17s npm create next-app 2m33.90s 1m13.31s 24.95s next.js project build 45.91s 21.01s 20.83s Benchmarks performed on a 1st generation Surface Pro with 64GB SSD. Your results will see a pronounced improvement with better hardware. Node.js 12.13 LTS used for next.js benchmarks.]]></summary></entry><entry><title type="html">Windows Subsystem for Linux (WSL)</title><link href="/wsl/2019/11/02/wsl_intro.html" rel="alternate" type="text/html" title="Windows Subsystem for Linux (WSL)" /><published>2019-11-02T00:00:00-07:00</published><updated>2019-11-02T00:00:00-07:00</updated><id>/wsl/2019/11/02/wsl_intro</id><content type="html" xml:base="/wsl/2019/11/02/wsl_intro.html"><![CDATA[<p>A large portion of my job deals with supporting Windows desktop applications
along with working with Linux on backend and embedded platforms.</p>

<p>Using WSL allows me to pop into a project from the command line, edit a line
or two with Vim, punch a commit in Git, and compile an executable in what feels
like seconds. Yet it keeps the familiar environment and supports business
applications I depend on.</p>

<ul>
  <li><a href="/wsl/2019/11/03/wsl_disk_perf.html">WSL Disk Performance</a></li>
  <li><a href="/wsl/2019/12/12/wsl_cross_plat_git.html">Git for Windows using WSL</a></li>
  <li><a href="/wsl/2022/02/20/wsl2_disk_perf.html">WSL2 Disk Performance</a></li>
  <li><a href="/wsl/2022/09/29/docker_wsl.html">Docker for Windows</a></li>
  <li>Copy/Paste between WSL and Windows</li>
</ul>

<p>and more…</p>]]></content><author><name></name></author><category term="wsl" /><category term="intro" /><summary type="html"><![CDATA[A large portion of my job deals with supporting Windows desktop applications along with working with Linux on backend and embedded platforms. Using WSL allows me to pop into a project from the command line, edit a line or two with Vim, punch a commit in Git, and compile an executable in what feels like seconds. Yet it keeps the familiar environment and supports business applications I depend on. WSL Disk Performance Git for Windows using WSL WSL2 Disk Performance Docker for Windows Copy/Paste between WSL and Windows and more…]]></summary></entry></feed>